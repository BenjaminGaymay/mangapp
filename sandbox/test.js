const CYPHER =
	'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';

const BASE =
	'eyJudW1iZXIiOjE3LCJ1cmkiOiJcL2xlY3R1cmUtZW4tbGlnbmVcLzEwMC0wMDAtbGV2ZWxzLW9mLWJvZHktcmVmaW5pbmctYWxsLXRoZS1kb2dzLWktcmFpc2UtYXJlLXRoZS1lbXBlcm9yXC8xN1wvIiwibWFuZ2FTbHVnIjoiMTAwLTAwMC1sZXZlbHMtb2YtYm9keS1yZWZpbmluZy1hbGwtdGhlLWRvZ3MtaS1yYWlzZS1hcmUtdGhlLWVtcGVyb3IiLCJpbWFnZXNMaW5rIjpb';

const b64 = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';

function findCypher() {
	let first = '';
	let second = '';

	const cypher = CYPHER.slice(0, BASE.length);
	for (let i = cypher.length - 1; i >= 0; i--) {
		if (second.includes(cypher[i])) continue;

		first += BASE[i];
		second += cypher[i];
	}

	const missing_first = findMissing(first);
	const second_key = second + findMissing(second);

	const combinaisons = listPossibilities(missing_first);
	for (const try_order of combinaisons) {
		if (!isValid(first + try_order, second_key)) continue;

		console.log('Found', first + try_order, second_key);
		return { first_key: first + try_order, second_key };
	}
}

function findMissing(str) {
	let missing = '';
	for (let i = 0; i < b64.length; i++) {
		if (!str.includes(b64[i])) missing += b64[i];
	}

	return missing;
}

function isValid(first_key, second_key) {
	const b64 = CYPHER.replace(/[A-Z0-9]/gi, char => first_key[second_key.indexOf(char)]);
	const ascii = Buffer.from(b64, 'base64')
		.toString('ascii')
		.replace(/[^\w\d :/".,{}\[\]]/g, '');

	const pages = ascii.match(/\[.+\]/);
	if (!pages || !pages?.at(0)) return false;

	try {
		const _ = JSON.parse(pages[0]);
		return true;
	} catch (e) {
		return false;
	}
}

function listPossibilities(first) {
	const possibilities = [];
	for (let i = 0; i < first.length; i++) {
		for (let j = i + 1; j < first.length; j++) {
			const temp = first.split('');
			[temp[i], temp[j]] = [temp[j], temp[i]];
			possibilities.push(temp.join(''));
		}
	}

	return possibilities;
}

const { first_key, second_key } = findCypher();
const decoded = CYPHER.replace(/[A-Z0-9]/gi, char => first_key[second_key.indexOf(char)]);
console.log(
	Buffer.from(decoded, 'base64')
		.toString('ascii')
		.replace(/[^\w\d :/".,{}\[\]]/g, '')
);
